---
title: "Python for JNTUK Students"
author: "Sreekanth Kolamala"
date: "M.tech Computer Science, IIT Kanpur"
header-includes:
- \usepackage{fancyhdr}
- \pagestyle{fancy}
- \fancyhead[CO,CE]{This is fancy header}
- \fancyfoot[CO,CE]{\copyright \ sreekanth.kolamala@gmail.com}
- \fancyfoot[LE,RO]{\thepage}
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(engine = "python")
```

#Types
Python has 5 data types-Numbers, Strings, Lists, Tuple, Dictionary. In this chapter, we will discuss Numbers and Strings. We will see the other 3 in the next chapter.

##Numbers
Numbers are further divided into 4:int, long, float, complex. int and long are used to represent whole numbers. float is used for numbers that have a decimal part. Languages like C have double type for really big floating point numbers. But python only has float. 
```{python}
a = 12
print type(a)
#type is a built-in function that returns the type of a variable
b = 12.3
print type(b)
c = 2323231211142342424
print type(c)
d = complex(2,3)
print d
print type(d)
```
The data type complex represent mathematical complex numbers that have a real and an imaginary part.

##Strings
Python doesn't differete between single quotes and double quotes. Unlike in C, the is not difference between char ans string-both are same.
```{python}
name = "sreekanth"
occupation = 'software engineer'
print type(name)
qoute = "I'am good" #observe that a single qoute can be used within double quotes
print "qoute:" + qoute
qoute = "qoute:" + 'He said "I am not going" to her'
print qoute
```

```{python, eval=FALSE}
qoute = "He said "I am not going" to her" #this will not work.
```
## Booleans
Boolean variables can be assigned either `True` or `False`
```{python}
flag = True
print flag
flag = False
print flag
```

## Operators
Variables are assigned values using the `=` operator. Variables are written when they are first assigned a value.
```{python}
number = 10
```
The variable `number` is assigned 10. Note that the type of variable `number` is not declared. This is not required because of the python type inference. Based on the operations we do on a variable, the python will automatic guess its type.
```{python}
#multiple assignments can be done in the same statement simultaneously.
a, b = 10,20
#a is assigned 10 and b is assigned 20.
print a,b
a,b = b,a
#a is assigned the value in b and b is assigned the value in a simultaneously. 
#this is a popular way of swapping numbers in python.
print a,b
```
### Arithmetic Operators
They are `+ - * / % **`.
`a%b` is gives the reminder of when a is divided by b. `a**b` gives a to power of b.

| operator       | example | result
--------------|---------|------
|    +  |  2 + 3       |5
|     -  | 2.3 - 3.5      | -1.2
| `*`  | 2\*1.5 | 3
| / | 5/2 | 2
| % | 5%2 | 1
| `**` | 5\*\*2 | 25
### Relational Operators

| operator       | example | result
--------------|---------|------
| > | 20 > 40 | False
|| 20 > 20 | False
| `>=` | 20 >= 20 | True
| < | 20 < 40 | True
|| 20 < 20 | False
| <= | 20 <= 20 | True
| == | 20 == 20 | True
||  20 == 40  | False
| != | 20 != 20 | False
||  20 != 40  | True

### Logical Operators

There are three logical operators: not, or, and. Also, >, >=, <, <=, ==, !=
```{python}
condition = True
print (not condition)
print (condition or False)
print (condition and False)
```
`not a` evaluates to the opposite of what `a` is. `a and b` evaluates to True only if both a, b are True. a or b evaluates to False if both a,b are False. They behave exactly like !, ||, && operators in C.

|     a   | not a       |
----------|--------------
|     True   | False       |
|     False  | True       |

|     a   | b      | a and b
----------|--------------|-----
|     True   | True       | True
|     True  | False       | False
|     False   | True       | False
|     False  | False       | False

|     a   | b      | a or b
----------|--------------|-----
|     True   | True       | True
|     True  | False       | True
|     False   | True       | True
|     False  | False       | False

###Membership Operator
The `in` operator is used to determine variable consists of other.
```{python}
isPresent = "sree" in "sreekanth"
print isPresent
```
We will discuss this operator in more detail in unit-3 once we complete lists.
```{python}
fruits = ["apple", "banana", "orange"]
print "apple" in fruits
#the 'in' operator can be used with the 'not' operator 
#to find out if a variable is not present in another
print "banana" not in fruits
```

## Terary operator

> a if condition else b

```{python}
number = 24
print "even" if number % 2 else "odd"
```


### Control flow
```{python}
a,b = 3,2
if(a > b):
  print "a is greater than b" #Notice this print stmt is indented 
  #this means that the print stmt is within the if block
```
Python seperates blocks based on there indentation. Notice the priNotice unlike other langauges, python doesn't use curly brackets{} to block. The above if statement can also be written as if-else statement.
```{python}
a,b = 10,20
if a > b:
  print "a is greater than b"
else:
  pass
```
`pass` is a keyword that represents an empty statement. It's is like an empty ; in C.
```{python}
a,b = 3,2
if a > b:
  print "this statement is within the if block"
  print "this statement aswell"
else:
  print "this statement is in the else block"
  print "this statement is also in the else block"
print "this statement is not in the if block. it's in the global block and will always print"
```
##Loops
### The for loop
```{python}
numbers = range(1,10)
for number in numbers:
  print number
```
```{python}
for aphlabet in "sreekanth":
  print aphlabet
```

```{python}
fruits = ["apple", "banana", "orange"]
while len(fruits) != 0:
  print fruits.pop()
print fruits
```

```{python}
numbers = range(0,10) #remember range() creates a list [0,1,2...,9]
#program to print even numbers
for i in numbers:
  if i%2 != 0:
    continue   
  print i #remember indentation rules: this stmt is in for block but not in if block
print "program end"
```
Each time the keyword `continue` is hit, the remaining part of the for loop is not executed

```{python}
numbers = range(0,10)
for i in numbers:
  if i%2 != 0:
    break  
  print i
print "program end"
```

Notice that this program produces nothing. When `i=1`, the `if` condition is True, and break statement is hit. When a break statement is hit, the loop, the break statement is in, is immediately exited.  

# Lists
lists are similar to C arrays but more powerful. Lists store multiple values. unlike C arrays, elements in a python list don't have be of the same type. lists are indexed from 0.
```{python}
fruits = ['apple', 'mango', 'pineapple']
numbers = [10, 20, 30, 40, 50]
#elements in a list can be accessed using index.
print numbers[1]
#even negative index is allowed, in which case length of list is added
#to the index. 
print numbers[-1]
fruitsandnumbers =  ['apple', 'mango', 'pineapple', 10, 20, 30, True]
#mixing elements of different types is fine
print fruitsandnumbers
print len(numbers)
#len is a built-in function used to find the length of lists.
integers = range(1,10)
print integers
#range(start,last) is built-in function that creates a list [start, start+1, ..., last-1] 
```

## Slicing
Slicing is a simple way of creating a new list from (part of) an old list.

\fbox{newList = oldList[start:end]}

```{python}
numbers = [10, 20, 30, 40, 50, 60, 70]
sublist = numbers[1:4]
print sublist
print numbers[0:3]
print numbers[:3] #missing starting number, with replaced with 0
print numbers[4:7]
print numbers[4:] #missing ending number is replaced with length of the list.
#negative indices can also be given. 
#In which case, the length of the list is added
print numbers[-2:7] 
print numbers[:-1]  #this will print all elements except the last one.
```
As shown in the example, sublist is a new list consisting of elements 1 to 3(remember, 'end' is not inclusive) in the numbers list. you can also specify negative numbers for indexes in which case, the length of list is automatically added. For example `numbers[-2:7]` is equivalent to `numbers[5:7]`. 

## List methods
Lists are not fixed in length. They increase and decrease when elements are added and removed.
```{python}
numbers = [10,20,30,40,50]  #creating a list
numbers.append(60)  #adds 60 at the end of the list
print numbers
numbers.insert(2, 25) #you can even add an element at a specific index
print numbers
```
Notice how the list gets re-adjusted. All the elements after index 1 are moved 1 place right the new element is insert at index 2.
you can delete an element from a list by using the keyword `del`.
```{python}
numbers = [10,20,30,40,50]
del numbers[1] #this will remove element at index 1
print numbers
```
Notice how the list is re-adjusted. All the elements after index 1 are moved 1 place left to full the list. The length of list is also reduced by 1.
```{python}
numbers = [10,20,30,40,50]  #creating a list
print numbers.pop() #removes and returns the last element in the list
print numbers
# More methods
print numbers.index(40) #returns the index of the element 40 if present
numbers = [30,20,40,10,50]
numbers.sort()  #sorts list
print numbers
```
## Strings as lists
In python, strings are lists. So, all the list operations can be done on strings.
```{python}
name = "sreekanth"
print name[0]
print name[1:5] #slicing
print name + "kolamala" # concatination
#
```

## Comprehensions

```{python, eval=FALSE}
[expression(x) for x in some_list if condition]
```
expression(x) is the formula used for creating the elements. The elements of some_list is are used in expression(x). The `if condition` is also optional used for filtering. Some examples will solidify these concepts.

```{python}
squares = [x**2 for x in range(10)]
print squares
#squares of even numbers:
squares = [x**2 for x in range(10) if x % 2 == 0]
print squares
squares = [x**2 for x in range(10) if not x % 2]
print squares
```

# Sets
Sets are like lists but duplicates are not allowed.

```{python}
presentees = {1,5,6,7,10,1,6,6,5}
print presentees
presentees.add(10)
print presentees
```

Common mathematical set operations like union, intersection can be easily done.
```{python}
setA = {1,2,3,4,5}
setB = {4,5,6,7,8}
print setA.union(setB)
print setA.intersection(setB)
```

# Dictionaries
Dictionaries(commmonly shortened to dict) are {key,value} pair data structures. Each element in a dict is a pair of key and value. Keys have to be uquine. Keys can be thought as indices with names. Dicts are similar to java maps.
```{python}
wordFrequency = {'a':1, 'b':5, 'c':10, 'e':15}
#Here all the strings('a', 'b', 'c', 'e' are keys)
#all the numbers are values(1,5,10,15)
#each key has a associated value.
#For example, wordFrequency can be used to store frequency of alphabets in a string
print wordFrequency['a']
#key can be used like an index of a list.
del wordFrequency['a']
#deleting is similar to list.
print wordFrequency
print 'd' in wordFrequency  #find out if a key exists in dict using the 'in' keyword
```
Accessing the key that isn't present in the dict can result in an exception. This can be avoided by checking if that key is present before accessing it.
```{python}
wordFrequency = {'a':1, 'b':5, 'c':10, 'e':15}
if('d' in wordFrequency):
  print wordFrequency['d']
else:
  print "not present"
```

# Functions
Functions are small pieces of code that we can reuse by calling them instead of writing code multiple times. Their syntax:
```{python, eval=FALSE}
def function_name(parameters):
  stmt
  stmt
  stmt
```
Few examples as usual will make things clear:
```{python, cache=TRUE}
#function defination
def add(a,b):
  c = a + b
  print c
```
We define a function by using the keyword `def`. Notice that all the stmts after the first statement are indented. This is python's way to say that these statements are part of the function defination and not in the global context. Not indenting would throw an error. We can call this function like this:
```{python, eval=FALSE}
#function calling
add(2,3)
add(2.3, 4.5)
add(a=2.3, b=4.5) #we can explicitly use the names of the parameter 
                  #as defined in function defination
add(b=4.5, a=2.3) #we can also change the order of parameters.
```

```{python, echo=FALSE}
def add(a,b):
  c = a + b
  print c
add(2,3)
add(2.3, 4.5)
add(a=2.3, b=4.5) #we can explicitly use the names of the parameter as defined in function defination
add(b=4.5, a=2.3) # we can also change the order of parameters.
```
Also notice that we were able to use the same add() function to add both ints and floats. Something we can't do in languages like C or Java.

### Default parameters
We could give default values to function parameters. In which case, if the function is called without the parameter, the default value is used. If an actual parameter is given then the default one is ignored.
```{python}
def print_series(n=10):
  for i in range(n):
    print i
print_series(5) #this will print till 5 #mental note: write this into 2 programs and eval, echo blocks
print_series()  #since no parameter is given, the default value 10 is assigned to n
                #and 0 till n are printed.
```

### Fruitful Functions
Instead of printing, a function can also return a value. 
```{python}
#function that returns the square of its parameter
def square(number):
  return number**2
#function calling
a = square(4) #the value returned by the function can be assigned to a variable.
print a
```

```{python}
def square(number):
  return number**2
print map(square, range(10))
```
Instead of defining a function, we can use **anonymous function**. Anonymous function are like regular functions except they don't have a name. They defined using the keyword, `lambda`. 
```{python}
print map(lambda x: x**2, range(10))
```
### Variable-length arguments
```{python}
# program to take variable number of parameters
def max(*numbers):
  result = None
  for number in numbers:
    if number > result:
      result = number
  print result
#you can call max() with any number of parameters
max(30,20)
max(20,30,60,70,40,50)
max(20)
max()
```
you can also mix normal parameters with variable number of parameters
```{python, error=TRUE}
def max(first, *numbers):
  result = first
  for number in numbers:
    if number > result:
      result = number
  print result
#you can call max() with atleast one parameter
max(30,20)
max(20,30,60,70,40,50)
max(20)
max() #this will throw an error
```

## Import statements
Often times, instead of writing code ourselves, we could you code written by others. This code is available in the form of libraries. We need to declare them before using them by writing an import statement. Its syntax:
```{python, eval=FALSE}
import library_name
from library_name import class_or_function_name
```
Some examples:
There is module called math that contains commonly used mathematical functions like square root{sqrt()} etc. To use them, we need to import the math module.
```{python, error=TRUE}
import math #you can call anything within math. 
print math.sqrt(25) #the full name math.sqrt() is requeried. 
print math.pi
print sqrt(25)
```

```{python, error=TRUE}
from math import sqrt #only importing sqrt and not the whole of math module.
print sqrt(25)  #full name not required.
print pi  #can't use anything else.
```
Some of these libraries are loaded along with python and hence need no import. Some examples:

# Object Oriented Programming OOP in Python
Classes are neat way to organize code. Consider we write code for a box. A box has 3 properties-height, width, bredth. We can use variable like box_height, box_width, box_bredth to represent them. But doing this makes 3 seperate variables that seem to have no relation. 
```{python}
class Box(object):
  static_variable = 10
  def set_height(self, h):
    self.height = h
  
  def get_height(self):
    return self.height

  def __init__(self, h, w, b):
    self.height = h
    self.weight = w
    self.bredth = b

  def volume(self):
    return self.height*self.weight*self.bredth
  
  def __len__(self):
    return 10

box = Box(2,3,4)
print box.volume()
print len(box)
```
I know that's a lot of code. Don't worry. Before we We are creating a class called Box that has variable height


## Magic methods
The beauty of python is in its magic methods. Lets us that we are defining a class to represent a family.
```{python}
class Family(object):
  def __init__(self, mems):
    self.members = mems
family = Family(['ram', 'priya', 'ravi'])
print family.members
# We can use the len() functin to find out how many family members are there.
print len(family.members)
```
But with magic methods, we could simplify this. 
```{python}
class Family(object):
  def __init__(self, mems):
    self.members = mems
  def __len__(self):
    return len(self.members)
family = Family(['ram', 'priya', 'ravi'])
print len(family) #notice the change
```
What we have achivied here is: Family is type we build just now. The python language didn't know about this before now. len is built-in function. we defined our class to work seemlessly with python's built-in functions. __len(self)__ is a magic method that gets called when len(family) is encountered. 
```{python}
class Family(object):
  def __init__(self, mems):
    self.members = mems
  def __repr__(self):
    return str(self.members)
  def __getitem__(self, name):
    return self.members[name]
family = Family(['ram', 'priya', 'ravi'])
print family    
print family[1]
```
An excellent guide for magic methods(don't forget to check the table towards the end of the article): http://minhhh.github.io/posts/a-guide-to-pythons-magic-methods

## Inheritance

Let's create a special kind of family: south indian family

```{python, eval=FALSE}
class South_Indian_Family(Family):
  pass

southy = South_Indian_Family(['ram', 'priya', 'ravi'])
print southy.members
print southy
```



```{python, echo=FALSE}
class Family(object):
  def __init__(self, mems):
    self.members = mems
  def __repr__(self):
    return str(self.members)
  def __getitem__(self, name):
    return self.members[name]
class South_Indian_Family(Family):
  pass

southy = South_Indian_Family(['ram', 'priya', 'ravi'])
print southy.members
print southy
```

## Exception Handling
Let's write a program to for a simple calculator. Our calculator repeatedly asks 2 numbers and  calculates their division. 

```{python, eval=FALSE}
while True:
	a = int(raw_input("enter numerator:"))
	b = int(raw_input("enter denominator:"))
	print a/b
```

```{python, echo=FALSE}
def divide(a,b):
  print "enter numerator:" + str(a)
  print "enter denominator:" + str(b)
  print a/b
divide(2.3, 4.5)
divide(5,2)
print "enter numerator:"
```
Looks good. This an never ending program(you can stop the program by pressing ctrl+z) lets see what happens when we give 0 for denominator
```{python, echo=FALSE, error=TRUE}
a,b=4,0
print "enter numerator:" + str(a)
print "enter denominator:" + str(b)
print a/b
```

The program stops with an error message. ... we can avoid this by using a try-except block

```{python, eval=FALSE}
while True:
	try:
		a = int(raw_input("enter numerator:"))
		b = int(raw_input("enter denominator:"))
		print a/b
	except ZeroDivisionError as e:
		print 'denominator cannot be zero. Try again'
```

```{python, echo=FALSE}
def divide(a,b):
  try:
    print "enter numerator:" + str(a)
    print "enter denominator:" + str(b)
    print a/b
  except ZeroDivisionError as e:
    print 'denominator cannot be zero. Try again'
  
divide(5,0)
divide(42,5)
print 'enter numerator:'
```

looks good. let's break this again. this time we will give invalid input.

```{python, echo=FALSE, error=TRUE}
a = 'e'
print 'enter numerator:' + a
int(a)
```
Giving a string instead of a number crashed the program. We can see from the error output, there was a ValueError error. Let's handle that.
```{python, eval=FALSE}
while True:
	try:
		a = int(raw_input("enter numerator:"))
		b = int(raw_input("enter denominator:"))
		print a/b
	except ZeroDivisionError as e:
		print 'denominator cannot be zero. Try again'
	except ValueError as e:
		print 'please enter numbers'
```

```{python, echo=FALSE}
a,b = 'string', 3
try:
  print "enter numerator:" + str(a)
  int(a)
  print "enter denominator:" + str(b)
  print a/b
except ZeroDivisionError as e:
  print 'denominator cannot be zero. Try again'
except ValueError as e:
	print 'please enter numbers'

a,b = 3, 0
try:
  print "enter numerator:" + str(a)
  print "enter denominator:" + str(b)
  print a/b
except ZeroDivisionError as e:
  print 'denominator cannot be zero. Try again'
except ValueError as e:
	print 'please enter numbers'

print 'enter numerator:'
```

# Lab programs

##Exercise 2 - Operations

a) Write a program to compute distance between two points taking input from the user
(Pythagorean Theorem)
```{python, eval=FALSE}
import math
x1 = int(raw_input("enter x1:"))
y1 = int(raw_input("enter y1:"))
x2 = int(raw_input("enter x2:"))
y2 = int(raw_input("enter y2:"))
distance = math.sqrt(math.pow(x2-x1, 2) + math.pow(y2-y1, 2))
print distance
```

b) Write a program add.py that takes 2 numbers as command line arguments and prints its sum.


##Exercise 8 - Functions

a) Write a function ball_collide that takes two balls as parameters and computes if they are
colliding. Your function should return a Boolean representing whether or not the balls are
colliding.
Hint: Represent a ball on a plane as a tuple of (x, y, r), r being the radius
If (distance between two balls centers) <= (sum of their radii) then (they are colliding)

b) Find mean, median, mode for the given set of numbers in a list.

```{python, eval=FALSE}
def mean(numbers):
    return float(sum(numbers)) / max(len(numbers), 1)

def median(numbers):
    if not numbers:
        return 0
    sortedNumbers = sorted(numbers)
    length = len(sortedNumbers)
    return (sortedNumbers[length/2] + sortedNumbers[(length-1)/2])/2.0

#if you are going to sort numbers, there is simpler way to find mode
def mode(numbers):
    frequencies = countWordFrequency(numbers)
    maximum = None
    result = None
    for number, frequency in frequencies.items():
        if maximum < frequency:
            maximum = frequency
            result = number
    return result

numbers = [2,3,5,2,10,25]
print mean(numbers), median(numbers), mode(numbers)
```

\fbox{My text!}

# Appendix


https://powerfulpython.com/store/p/restful-api-server/